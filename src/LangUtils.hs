module LangUtils where

import Codec.Binary.UTF8.String
import Control.Monad
import Data.Char
import Data.List

errorHeader = "__ERROR"

spread :: [(a,[b])] -> [(a,b)]
spread = concat . map (\(a,b) -> map (\x -> (a,x)) b)

reduce :: [[String]] -> [String]
reduce = nub . concat

isNotError :: [String] -> Bool
isNotError (h:_) | h /= errorHeader = True
isNotError _ = False

unerror :: [String] -> [String]
unerror (errorHeader:t) = t
unerror x = x

-- gets the string ready for parsing
prepareString :: String -> String
prepareString = encodeString . firstToLower . removeQuestionMarks . removeQuotes . trim
                  
trim :: String -> String
trim = f . f
   where f = reverse . dropWhile isSpace
   
removeQuotes :: String -> String
removeQuotes = aux . (flip split) "\""
                where aux (a:b:t) = a ++ underscore b ++ aux t
                      aux x = concat x
                      
underscore :: String -> String
underscore [] = []
underscore (' ':t) = '_':(underscore t)
underscore (h:t) = h:(underscore t)
                  
-- removes Â¿ from the beginning
removeQuestionMarks :: String -> String
removeQuestionMarks = f .f
  where f = reverse . dropWhile isQuestionMark
                              
isQuestionMark :: Char -> Bool
isQuestionMark '?' = True
isQuestionMark 'Â¿' = True
isQuestionMark  _  = False

-- ensures sentence starts in lower case for parsing
firstToLower :: String -> String
firstToLower [] = []
firstToLower (h:t) = if isLetter h then (toLower h):t
                                 else h:(firstToLower t)

-- fixes the string after it has been generated by the grammar
fixStrings :: IO [String] -> IO [String]
fixStrings = liftM (map fixString)
  
-- fixes spaces after and before brackets, uppercases first letter of the sentence
fixString :: String -> String
fixString s = let a = split s "( "
               in let b = intercalate "(" a 
              in let c = split b " )"
              in let d = intercalate ")" c
              in let e = split d " ,"
              in let (f':f'') = intercalate "," e
              in let g = (toUpper f'):(f'') ++ "."
              in decodeString g
              
-- splits a string into substrings, by the cutting point provided
-- (that gets removed)
split :: Eq a => [a] -> [a] -> [[a]]
split str sub = splitAux str sub [[]]

splitAux :: Eq a => [a] -> [a] -> [[a]] -> [[a]]
splitAux str [] _ = groupBy (\x y -> False) str
splitAux [] _ acc = deepReverse acc
splitAux str sub acc = if isPrefixOf sub str
                          then
                            splitAux (drop (length sub) str) sub ([]:acc)
                          else
                            splitAux (tail str) sub (((head str):(head acc)):tail acc)
                      
-- reverses a list and the sublists in it              
deepReverse :: [[a]] -> [[a]]
deepReverse [h] = [reverse h]
deepReverse (h:t) = (deepReverse t) ++ [reverse h]